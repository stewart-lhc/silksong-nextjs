import { ImageResponse } from 'next/og';
import { NextRequest } from 'next/server';
import { env } from '@/lib/env';

// OGå›¾ç‰‡å°ºå¯¸é…ç½®
const OG_WIDTH = 1200;
const OG_HEIGHT = 630;

// ç±»å‹å®šä¹‰
type Language = 'en' | 'zh';
type OGVariant = 'default' | 'countdown' | 'released' | 'news';

/**
 * éªŒè¯å’Œè§„èŒƒåŒ–è¯­è¨€å‚æ•°
 */
function normalizeLanguage(lang?: string): Language {
  if (lang === 'zh' || lang === 'zh-CN' || lang === 'zh-TW') return 'zh';
  return 'en'; // é»˜è®¤è‹±æ–‡
}

/**
 * æ ¹æ®è¯­è¨€è·å–æ–‡æœ¬
 */
function getLocalizedText(lang: Language) {
  const texts = {
    en: {
      title: 'Hollow Knight: Silksong',
      subtitle: 'The eagerly awaited sequel',
      releasedText: 'Now Available!',
      comingSoonText: 'Coming Soon',
      daysText: 'days remaining',
      hoursText: 'hours remaining',
      minutesText: 'minutes remaining',
    },
    zh: {
      title: 'ç©ºæ´éª‘å£«ï¼šä¸ä¹‹æ­Œ',
      subtitle: 'ä¸‡ä¼—æœŸå¾…çš„ç»­ä½œ',
      releasedText: 'ç°å·²å‘å”®ï¼',
      comingSoonText: 'å³å°†å‘å”®',
      daysText: 'å¤©åå‘å”®',
      hoursText: 'å°æ—¶åå‘å”®',
      minutesText: 'åˆ†é’Ÿåå‘å”®',
    }
  };
  
  return texts[lang];
}

/**
 * è®¡ç®—å€’è®¡æ—¶æ–‡æœ¬
 */
function getCountdownText(lang: Language): string {
  const releaseDate = new Date(env.SILKSONG_RELEASE_ISO);
  const now = new Date();
  const diff = releaseDate.getTime() - now.getTime();
  
  const texts = getLocalizedText(lang);
  
  if (diff <= 0) {
    return texts.releasedText;
  }
  
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  
  if (days > 0) {
    return `${days} ${texts.daysText}`;
  } else if (hours > 0) {
    return `${hours} ${texts.hoursText}`;
  } else {
    return `${minutes} ${texts.minutesText}`;
  }
}

/**
 * ç”ŸæˆOGå›¾ç‰‡çš„JSXå†…å®¹
 */
function generateOGContent({
  title,
  subtitle,
  countdownText,
  isReleased,
  variant,
  lang,
}: {
  title: string;
  subtitle: string;
  countdownText: string;
  isReleased: boolean;
  variant: OGVariant;
  lang: Language;
}) {
  const bgColor = isReleased ? '#1a5f3f' : '#2a1810';
  const textColor = '#ffffff';
  const accentColor = isReleased ? '#4ade80' : '#f59e0b';

  return (
    <div
      style={{
        height: '100%',
        width: '100%',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: bgColor,
        backgroundImage: 'linear-gradient(135deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(0,0,0,0.1) 100%)',
        fontFamily: `${env.OG_FONT_PRIMARY}, ${env.OG_FONT_FALLBACK || 'sans-serif'}`,
        position: 'relative',
      }}
    >
      {/* LogoåŒºåŸŸ */}
      <div
        style={{
          display: 'flex',
          alignItems: 'center',
          marginBottom: '32px',
        }}
      >
        <div
          style={{
            width: '80px',
            height: '80px',
            borderRadius: '50%',
            backgroundColor: 'rgba(255,255,255,0.2)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '32px',
            marginRight: '24px',
          }}
        >
          ğŸ¦‹
        </div>
      </div>

      {/* æ ‡é¢˜åŒºåŸŸ */}
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          textAlign: 'center',
          marginBottom: '48px',
        }}
      >
        <h1
          style={{
            fontSize: lang === 'zh' ? '48px' : '56px',
            fontWeight: 800,
            color: textColor,
            margin: 0,
            marginBottom: '16px',
            textShadow: '0 4px 8px rgba(0,0,0,0.3)',
          }}
        >
          {title}
        </h1>
        <p
          style={{
            fontSize: lang === 'zh' ? '20px' : '24px',
            color: textColor,
            margin: 0,
            opacity: 0.9,
          }}
        >
          {subtitle}
        </p>
      </div>

      {/* å€’è®¡æ—¶åŒºåŸŸ */}
      <div
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          backgroundColor: accentColor,
          borderRadius: '16px',
          padding: '24px 48px',
          boxShadow: '0 8px 32px rgba(0,0,0,0.2)',
        }}
      >
        <p
          style={{
            fontSize: lang === 'zh' ? '36px' : '40px',
            fontWeight: 700,
            color: '#000000',
            textAlign: 'center',
            margin: 0,
          }}
        >
          {countdownText}
        </p>
      </div>

      {/* å“ç‰Œä¿¡æ¯ */}
      <div
        style={{
          position: 'absolute',
          bottom: '32px',
          right: '48px',
          display: 'flex',
          alignItems: 'center',
          color: textColor,
          opacity: 0.7,
          fontSize: '18px',
        }}
      >
        <div
          style={{
            backgroundColor: 'rgba(255,255,255,0.1)',
            borderRadius: '8px',
            padding: '8px 16px',
            fontSize: '14px',
            color: textColor,
            fontWeight: 600,
            textTransform: 'uppercase',
          }}
        >
          {lang}
        </div>
      </div>
    </div>
  );
}

/**
 * GETè¯·æ±‚å¤„ç†å™¨
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // è·å–å‚æ•°
    const title = searchParams.get('title') || '';
    const subtitle = searchParams.get('subtitle') || '';
    const lang = normalizeLanguage(searchParams.get('lang') || 'en');
    const variant = (searchParams.get('variant') || 'default') as OGVariant;
    
    // ç”Ÿæˆæœ¬åœ°åŒ–æ–‡æœ¬
    const texts = getLocalizedText(lang);
    const finalTitle = title || texts.title;
    const finalSubtitle = subtitle || texts.subtitle;
    const countdownText = getCountdownText(lang);
    
    // æ£€æŸ¥æ˜¯å¦å·²å‘å¸ƒ
    const releaseDate = new Date(env.SILKSONG_RELEASE_ISO);
    const isReleased = Date.now() >= releaseDate.getTime();
    
    // ç”ŸæˆETagç”¨äºç¼“å­˜
    const etag = `"${Buffer.from(`${finalTitle}-${finalSubtitle}-${countdownText}-${variant}-${lang}-${isReleased}`).toString('base64')}"`;
    
    // æ£€æŸ¥If-None-Matchå¤´
    const ifNoneMatch = request.headers.get('If-None-Match');
    if (ifNoneMatch === etag) {
      return new Response(null, { status: 304 });
    }
    
    // ç”Ÿæˆå›¾ç‰‡
    const imageResponse = new ImageResponse(
      generateOGContent({
        title: finalTitle,
        subtitle: finalSubtitle,
        countdownText,
        isReleased,
        variant,
        lang,
      }),
      {
        width: OG_WIDTH,
        height: OG_HEIGHT,
        fonts: await loadFonts(),
      }
    );
    
    // è®¾ç½®ç¼“å­˜å¤´
    const headers = new Headers();
    headers.set('Content-Type', 'image/png');
    headers.set('Cache-Control', 'public, max-age=3600, s-maxage=3600');
    headers.set('ETag', etag);
    headers.set('Vary', 'Accept-Language');
    
    return new Response(imageResponse.body, {
      status: 200,
      headers,
    });
    
  } catch (error) {
    console.error('OG image generation error:', error);
    
    // è¿”å›é”™è¯¯ä¿¡æ¯
    return new Response(
      JSON.stringify({
        error: 'Failed to generate OG image',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      }),
      {
        status: 500,
        headers: {
          'Content-Type': 'application/json',
        },
      }
    );
  }
}

/**
 * åŠ è½½å­—ä½“
 */
async function loadFonts() {
  try {
    const fonts = [];
    
    // å°è¯•åŠ è½½ä¸»è¦å­—ä½“
    try {
      const primaryFontData = await fetch(
        new URL(`https://fonts.googleapis.com/css2?family=${env.OG_FONT_PRIMARY}:wght@400;600;700;800&display=swap`)
      ).then((res) => res.arrayBuffer());
      
      fonts.push({
        name: env.OG_FONT_PRIMARY,
        data: primaryFontData,
        style: 'normal' as const,
      });
    } catch (fontError) {
      console.warn(`Failed to load primary font ${env.OG_FONT_PRIMARY}:`, fontError);
      
      // å¦‚æœè®¾ç½®äº†åœ¨å­—ä½“ç¼ºå¤±æ—¶å¤±è´¥
      if (env.FAIL_ON_OG_FONT_MISSING === 'true') {
        throw new Error(`Primary font ${env.OG_FONT_PRIMARY} is required but failed to load`);
      }
    }
    
    // å°è¯•åŠ è½½åå¤‡å­—ä½“
    if (env.OG_FONT_FALLBACK && fonts.length === 0) {
      try {
        const fallbackFontData = await fetch(
          new URL(`https://fonts.googleapis.com/css2?family=${env.OG_FONT_FALLBACK}:wght@400;600;700;800&display=swap`)
        ).then((res) => res.arrayBuffer());
        
        fonts.push({
          name: env.OG_FONT_FALLBACK,
          data: fallbackFontData,
          style: 'normal' as const,
        });
      } catch (fallbackError) {
        console.warn(`Failed to load fallback font ${env.OG_FONT_FALLBACK}:`, fallbackError);
      }
    }
    
    // å¦‚æœæ²¡æœ‰å­—ä½“å¯ç”¨ï¼Œä½¿ç”¨ç³»ç»Ÿé»˜è®¤å­—ä½“
    if (fonts.length === 0) {
      console.warn('No fonts loaded, using system defaults');
    }
    
    return fonts;
    
  } catch (error) {
    console.error('Font loading error:', error);
    return [];
  }
}

/**
 * POSTè¯·æ±‚å¤„ç†å™¨ - ç”¨äºé¢„çƒ­ç¼“å­˜
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { variants = ['default'], languages = ['en', 'zh'] } = body;
    
    const results = [];
    
    for (const variant of variants) {
      for (const lang of languages) {
        try {
          // ç”Ÿæˆé¢„çƒ­è¯·æ±‚
          const searchParams = new URLSearchParams({
            variant,
            lang,
          });
          
          const warmupUrl = new URL(`/api/og?${searchParams}`, request.url);
          const warmupResponse = await fetch(warmupUrl);
          
          results.push({
            variant,
            lang,
            status: warmupResponse.status,
            cached: warmupResponse.headers.get('x-cache') === 'HIT',
          });
        } catch (error) {
          results.push({
            variant,
            lang,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        }
      }
    }
    
    return Response.json({
      message: 'Cache warmup completed',
      results,
      timestamp: new Date().toISOString(),
    });
    
  } catch (error) {
    console.error('Cache warmup error:', error);
    
    return Response.json(
      {
        error: 'Cache warmup failed',
        message: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString(),
      },
      { status: 500 }
    );
  }
}